# Run with Python 3
# Copyright 2019 VMware, Inc.
# SPDX-License-Identifier: BSD-2-Clause
"""\
Unit tests for the Doctor tool end-to-end.

Run just these tests like:

    python3 test/test_doctor.py
"""
#
# Standard library imports, in alphabetic order.
#
# Sequence comparison module.
# https://docs.python.org/3/library/difflib.html#difflib.context_diff
from difflib import context_diff
#
# Module for removing files and working with paths.
# https://docs.python.org/3/library/os.html#os.remove
# https://docs.python.org/3/library/os.path.html
import os
#
# Module for OO path handling.
# https://docs.python.org/3/library/pathlib.html
from pathlib import Path
#
# Regular expressions module.
# https://docs.python.org/3/library/re.html
import re
#
# Temporary file module.
# https://docs.python.org/3/library/tempfile.html
import tempfile
#
# Unit test framework.
# https://docs.python.org/3/library/unittest.html
import unittest
#
# Local imports
#
# Handy common code to put the Doctor and mistune modules on the import path.
import set_up
#
# Classes under test.
from doctor import comment_block, comment_line, doc_markdown, parser, getter
from doctor.doctor_class import Doctor

class TestDoctor(unittest.TestCase):
    # Only use .match() method, not .search() method.
    _plingSpace = re.compile(r'!( *)$')

    def test_resolve_mode(self, adHoc=False):
        with set_up.temporary_data_directory() as temporaryData:
            names = self._assert_overwrite_all(temporaryData, 80, adHoc)
        self.assertListEqual(
            names, ['extractablesource.h', 'source.h', 'swiftsource.swift'])
    
    def test_resolve_mode_adhoc(self):
        self.test_resolve_mode(True)
    
    def _assert_overwrite_all(self, temporaryData, maxWidth, adHoc):
        doctor = Doctor()
        doctor.extractMode = False
        doctor.maxWidth = maxWidth
        doctor.adHoc = adHoc
        doctor.load_cache(set_up.data_path('cache.md'))
        reportedNames = []
        for report in doctor.overwrite_all((temporaryData,)):
            if not report['overwrote']:
                continue
            
            path = report['path']
            reportedNames.append(Path(path).name)

            # Uncomment the following to force the test to fail.
            # with open(path, mode="a") as errorFile:
            #     errorFile.write('blib\n')
            
            self._assert_file_content_same(
                path
                , self._comparison_path(
                    path, temporaryData, '_adhoc_output' if adHoc else '_output'
                )
            )
        reportedNames.sort()
        return reportedNames
    
    def _comparison_path(self, path, temporaryData, suffix):
        # Every path must be in the temporary data directory ... but just in
        # case, assert that here.
        self.assertTrue(
            path.startswith(temporaryData)
            , f'\nActual path:"{path}"\nExpected start:"{temporaryData}"')

        # I feel like the following join should be an os.path.join but it
        # doesn't work, perhaps because the second part starts with a slash.
        buildPath = ''.join((set_up.dataPath, path[len(temporaryData):]))
        compareStub, extension = os.path.splitext(buildPath)
        return suffix.join((compareStub, extension))

    def test_extract_mode(self, adHoc=False):
        with set_up.temporary_data_directory(
            ignoring=['source.h']
        ) as temporaryData:
            doctor = Doctor()
            doctor.extractMode = True
            doctor.adHoc = adHoc
            for report in doctor.overwrite_all((temporaryData,)):
                if not report['overwrote']:
                    continue
                path = report['path']
                self._assert_file_content_same(
                    path,
                    self._comparison_path(path, temporaryData, '_extract'))
                
                path = report['extractPath']
                self._assert_file_content_same(
                    path, self._comparison_path(
                        path, temporaryData, '_extract')
                    # Next line specifies ignoring the lines that have on them:
                    # -   Extraction date and time.
                    # -   Path, which will be a temporary one.
                    # -   Extract Path, which will also be temporary.
                    , (2, 4, 9))
            
            # Now test that the same output is generated by:
            # -   Running extract and then resolve.
            # -   Just running resolve.
            self.assertListEqual(
                self._assert_overwrite_all(temporaryData, 80, adHoc),
                ['extractablesource.h', 'swiftsource.swift'])

    def test_extract_mode_adhoc(self):
        self.test_extract_mode(True)

    def test_extract_to_subdir(self, adHoc=False):
        with set_up.temporary_data_directory(
            ignoring=['source.h']
        ) as temporaryData:
            doctor = Doctor()
            doctor.extractMode = True
            doctor.adHoc = adHoc

            # Testing extract dir is observed as a subdir
            extractDir = 'documentation'
            doctor.extractDir = os.path.join(temporaryData, extractDir)

            for report in doctor.overwrite_all((temporaryData,)):
                if not report['overwrote']:
                    continue
                path = report['path']

                # example extracted header
                cmpHdrExtractPath = self._comparison_path(
                    path, temporaryData, '_extract')

                # Compare report source with extracted source 
                self._assert_file_content_same(
                    path, cmpHdrExtractPath
                    # ignore line with the different path
                    ,[7,9])

                path = report['extractPath']
                
                # example extracted documentation
                cmpDocExtractPath = self._comparison_path(
                            path, os.path.join(temporaryData, doctor.extractDir), '_extract');

                # Compare extraction
                self._assert_file_content_same(
                    path, cmpDocExtractPath                    
                    # Next line specifies ignoring the lines that have on them:
                    # -   Extraction date and time.
                    # -   Path, which will be a temporary one.
                    # -   Extract Path, which will also be temporary.
                    , (2, 4, 9))

            copied = self._copy_md_files(temporaryData, doctor.extractDir)
            # print(f'Copied: {copied}')

            # Now test that the same output is generated by:
            # -   Running extract and then resolve.
            # -   Just running resolve.
            self.assertListEqual(
                self._assert_overwrite_all(temporaryData, 80, adHoc),
                ['extractablesource.h', 'swiftsource.swift'])

    def test_extract_to_subdir_adhoc(self):
        self.test_extract_to_subdir(True)

    def _copy_md_files(self, dataSource, extractDir):
        copied = []
        # Extract mode doesn't make any adjustments to relative doc: URI paths.
        # That means they might fail to resolve. The test suite data includes
        # relative doc URI paths.  
        # The next code bodges that by copying any Markdown files.
        for tail in ("", "/../data", "/data"):
            copied.extend(set_up.copy_files(
                dataSource, extractDir + tail, ".md"))
        return copied

    def test_extract_to_external_dir(self, adHoc=False):
        # Create a root dir to copy the source to.
        with set_up.temporary_data_directory(
            ignoring=['source.h']
        ) as temporaryData:
            # Create a separate temporary dir (external to the temporaryRoot) to
            # extract into.
            with set_up.temporary_working_directory() as temporaryExtractDir:
                doctor = Doctor()
                doctor.extractMode = True

                # Testing extract dir is observed
                doctor.extractDir = temporaryExtractDir

                for report in doctor.overwrite_all((temporaryData,)):
                    if not report['overwrote']:
                        continue
                    path = report['path']

                    # example extracted header
                    cmpHdrExtractPath = self._comparison_path(
                        path, temporaryData, '_extract')

                    # Compare extraction
                    self._assert_file_content_same(
                        path, cmpHdrExtractPath
                        # ignore line with the different path
                        ,[7,9])

                    path = report['extractPath']

                    # example extracted documentation
                    filepath = os.path.splitext(cmpHdrExtractPath)
                    cmpDocExtractPath = '.'.join([filepath[0],'md'])
                    
                    # compare extracted docs
                    self._assert_file_content_same(
                        path,                  
                        cmpDocExtractPath 
                        # Next line specifies ignoring the lines that have on them:
                        # -   Extraction date and time.
                        # -   Path, which will be a temporary one.
                        # -   Extract Path, which will also be temporary.
                        , (2, 4, 9))

                # Now test that the same output is generated by:
                # -   Running extract and then resolve.
                # -   Just running resolve.
                # -   This also verifies the 'doc://' url is correct
                self.assertListEqual(
                    self._assert_overwrite_all(temporaryData, 80, adHoc),
                    ['extractablesource.h', 'swiftsource.swift'])

    def test_extract_to_external_dir_adhoc(self):
        self.test_extract_to_external_dir(True)

    def test_iterators(self):
        # Test the ad hoc iterators.

        sourcePath = set_up.data_path('source.h')
        comparePath = set_up.data_path('source_output.h')

        # Following lines build up an iterator nest of all the Doctor stages.
        # The array isn't necessary here, because only the last iterator is
        # needed, but it could be useful in future.
        readers = [comment_line.SourceLine.read_file(sourcePath)]
        readers.append(
            parser.SlashStarsParser.read(readers[-1]))
        readers.append(
            comment_block.CommentBlock.read(readers[-1], sourcePath))
        docGetter = getter.DocGetter()
        docGetter.load(set_up.data_path('cache.md'))
        markdownParser = doc_markdown.MarkdownParser(docGetter)
        readers.append(
            markdownParser.read(readers[-1], sourcePath))

        outputPath = None
        # Set a `mode` without binary for now; worry about encoding later.
        with tempfile.NamedTemporaryFile(mode='w', delete=False) as outputFile:
            outputPath = outputFile.name
            for item in readers[-1]:
                outputFile.writelines(item.outputs(80))
        self._assert_file_content_same(outputPath, comparePath)
        os.remove(outputPath)
    
    def _assert_file_content_same(self, actual, expected, ignore=None):
        '''\
        Compare two files, using the Python difflib.context_diff subroutine, and
        assert that there are zero differences between them.
        
        Line numbers in the `ignores` parameter aren't compared. For this
        parameter, the first line in a file is number 1, not zero.
        '''
        diffs = None
        with open(actual) as actualFile, open(expected) as expectedFile:
            #
            # Read each file into a list.
            actualLines = actualFile.readlines()
            expectedLines = expectedFile.readlines()
            #
            # Fix the ignores by changing the actual line to be the same as the
            # expected line. This is better than removing the lines because it
            # preserves the line numbers.
            # Both lines get a marker text as a prefix, in case a nearby line is
            # different and an ignored line appears in the diff output.
            if ignore is not None:
                for lineNumber in ignore:
                    ignoreLine = 'IGNORED ' + expectedLines[lineNumber-1]
                    expectedLines[lineNumber-1] = ignoreLine
                    actualLines[lineNumber-1] = ignoreLine
            #
            # Actual diff. The fromfile and tofile parameters are labels.
            # The output of the diff becomes the test failure message if the
            # assert condition isn't met.
            diffs = list(context_diff(
                actualLines, expectedLines
                , fromfile="actual {}".format(os.path.basename(actual))
                , tofile="expected {}".format(os.path.basename(expected))))
        
        for index, diff in enumerate(diffs):
            match = self._plingSpace.match(diff)
            if match is not None:
                diffs[index] = ''.join((
                    diff.splitlines()[0],
                    f"!space offset:{match.end(1) - (match.start(1) + 1)}\n"
                ))

        self.assertEqual(len(diffs), 0,
                         "".join(( "Output file isn't as expected:\n", *diffs)))
    
    def test_IO_errors(self):
        wrongPath = "/path/that/does/not/exist.h"
        # Careful check that the path doesn't exist.
        self.assertFalse(os.path.exists(wrongPath), wrongPath)

        from doctor import main as doctorMain
        with self.assertRaises(OSError) as context:
            doctorMain.main('test_IO_errors', ('-i', wrongPath))
        exceptionStr = str(context.exception)
        self.assertTrue(
            'No such file or directory' in exceptionStr, exceptionStr)
 
if __name__ == '__main__':
    unittest.main()
